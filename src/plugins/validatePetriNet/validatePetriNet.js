/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Fri Apr 30 2021 18:42:53 GMT-0400 (Eastern Daylight Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define(['plugin/PluginConfig', 'text!./metadata.json', 'plugin/PluginBase', 'he'], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    he
) {
    'use strict';

    const fs = require('fs'),
        path = require('path'),
        childProcess = require('child_process');
    const ejs = require('ejs');
    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of validatePetriNet.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin validatePetriNet.
     * @constructor
     */
    function validatePetriNet() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    validatePetriNet.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    validatePetriNet.prototype = Object.create(PluginBase.prototype);
    validatePetriNet.prototype.constructor = validatePetriNet;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    validatePetriNet.prototype.main = function (callback) {
        const self = this;
        self.callback = callback;

        try {
            const dir = fs.mkdtempSync('validation-check');
            const filePath = path.join(dir, 'model.4ml');
            const fd = fs.openSync(filePath, 'wx+');
            this.buildFormulaEjsTemplate()
                .then((model) => {
                    fs.writeFileSync(fd, model);
                    fs.closeSync(fd);
                    self.validateWithFormula(filePath);

                    fs.unlinkSync(filePath);
                    fs.rmdirSync(dir);
                })
                .catch((err) => {
                    callback(err);
                });
        } catch (err) {
            callback(err);
        }
    };

    validatePetriNet.prototype.validateWithFormula = function (filePath) {
        const self = this;
        const formulaPath = path.join('src', 'common', 'formula', 'publish', 'CommandLine.exe');

        const formula = childProcess.spawn('powershell.exe', ['-Command', formulaPath]);

        const conformities = [];
        const domainOrder = ['MarkedGraphs', 'FreeChoicePetriNets', 'StateMachines', 'WorkflowNets'];

        formula.stdout.on('data', function (data) {
            const dataStr = data.toString();
            if (dataStr.includes('true')) {
                conformities.push(true);
            } else if (dataStr.includes('false')) {
                conformities.push(false);
            }
        });

        const modelName = self.core.getAttribute(self.activeNode, 'name').replace(/ /g, '');

        const commands = [
            'w on',
            `l ${filePath}`,
            `qr ${modelName}_markedGraph MarkedGraphs.conforms`,
            'ls',
            'tul *',
            `qr ${modelName}_freeChoice FreeChoicePetriNets.conforms`,
            'ls',
            'tul *',
            `qr ${modelName}_stateMachine StateMachines.conforms`,
            'ls',
            'tul *',
            `qr ${modelName}_workflow WorkflowNets.conforms`,
            'ls',
            'x',
        ];

        commands.forEach(function (cmd) {
            formula.stdin.write(cmd + '\n');
        });
        formula.stdin.end();

        formula.stdout.once('close', () => {
            const conformityInfo = domainOrder
                .map((domain, index) => [domain, conformities[index]])
                .map(
                    ([domain, conforms]) =>
                        `your model is ${conforms ? '' : 'not '} a ${domain.substring(0, domain.length - 1)}`
                );
            conformityInfo.forEach((message) => self.createMessage(self.activeNode, message));
            self.result.setSuccess(true);
            self.callback(null, self.result);
        });
        this.logger.debug(formulaPath);
    };

    validatePetriNet.prototype.buildFormulaEjsTemplate = async function () {
        const { activeNode, core } = this;

        return this.getModelContentParameters().then((modelContentParams) => {
            const modelContentTemplate = core.getAttribute(activeNode, 'formulaModelContent');
            const modelContent = ejs.render(modelContentTemplate, modelContentParams);

            const domain = core.getAttribute(activeNode, 'formulaDomain');
            const name = core.getAttribute(activeNode, 'name').replace(/ /g, '');
            const modelTemplate = core.getAttribute(activeNode, 'formulaModel');
            const model = he.decode(ejs.render(modelTemplate, { domain, name, modelContent }));
            return model;
        });
    };

    validatePetriNet.prototype.getModelContentParameters = async function () {
        const { activeNode, core, META } = this;
        const trimGuid = (node) => core.getGuid(node).replace(/-/g, '');
        return await core
            .loadOwnSubTree(activeNode)
            .then(async (nodes) => {
                const modelContentParameters = { places: [], transitions: [], flows: [] };
                for (const node of nodes) {
                    const id = trimGuid(node);
                    const name = core.getAttribute(node, 'name').replace(/ /g, '');
                    if (core.isInstanceOf(node, META['Place'])) {
                        const marks = core.getAttribute(node, 'marks');
                        modelContentParameters.places.push({ id, name, marks });
                    } else if (core.isInstanceOf(node, META['Transition'])) {
                        modelContentParameters.transitions.push({ id, name });
                    } else if (core.isInstanceOf(node, META['Flow'])) {
                        const isStart = core.isInstanceOf(node, META['Input Flow']);
                        const src = await core.loadPointer(node, 'src');
                        const dst = await core.loadPointer(node, 'dst');
                        const srcId = trimGuid(src);
                        const dstId = trimGuid(dst);
                        const srcName = core.getAttribute(core.getParent(src), 'name');
                        const dstName = core.getAttribute(core.getParent(dst), 'name');
                        const weight = core.getAttribute(node, 'weight');
                        modelContentParameters.flows.push({ id, srcId, dstId, weight, isStart, srcName, dstName });
                    }
                }

                return modelContentParameters;
            })
            .catch((ex) => {
                throw ex;
            });
    };

    return validatePetriNet;
});
