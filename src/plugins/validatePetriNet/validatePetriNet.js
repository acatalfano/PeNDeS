/*globals define*/
/*eslint-env node, browser*/

const { Console } = require('console');
const { result } = require('lodash');

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Fri Apr 30 2021 18:42:53 GMT-0400 (Eastern Daylight Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define(['plugin/PluginConfig', 'text!./metadata.json', 'plugin/PluginBase', 'he'], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    he
) {
    'use strict';

    //TODO: delete whatever wasn't needed...
    const fs = require('fs'),
        path = require('path'),
        os = require('os'),
        childProcess = require('child_process');
    const ejs = require('ejs');
    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of validatePetriNet.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin validatePetriNet.
     * @constructor
     */
    function validatePetriNet() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    validatePetriNet.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    validatePetriNet.prototype = Object.create(PluginBase.prototype);
    validatePetriNet.prototype.constructor = validatePetriNet;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    validatePetriNet.prototype.main = function (callback) {
        // Use this to access core, project, result, logger etc from PluginBase.
        const self = this;

        const result = self.result;
        debugger;

        // Using the logger.
        // self.logger.debug('This is a debug message.');
        // self.logger.info('This is an info message.');
        // self.logger.warn('This is a warning message.');
        // self.logger.error('This is an error message.');

        // Using the coreAPI to make changes.
        const nodeObject = self.activeNode;

        //const filename = cuid() + '.4ml';

        //fs.mkdirSync()
        //const dirPath = path.join()
        //const tempDir = fs.mkdtempSync('my_test_dir');
        //self.logger.info(tempDir);

        try {
            const dir = fs.mkdtempSync('validation-check');
            const filePath = path.join(dir, 'model.4ml');
            const fd = fs.openSync(filePath, 'wx+');
            this.buildFormulaEjsTemplate()
                .then((model) => {
                    fs.writeFileSync(fd, model);
                    fs.closeSync(fd);
                    //TODO: validation check here!
                    self.validateWithFormula(filePath);

                    fs.unlinkSync(filePath);
                    fs.rmdirSync(dir);
                    result.setSuccess(true);
                    callback(null, { ...result, path });
                })
                .catch((err) => {
                    callback(err);
                });
        } catch (err) {
            callback(err);
        }
        // self.core.setAttribute(nodeObject, 'name', 'My new obj');
        // self.core.setRegistry(nodeObject, 'position', { x: 70, y: 70 });

        // This will save the changes. If you don't want to save;
        // exclude self.save and call callback directly from this scope.
        // self.save('validatePetriNet updated model.')
        //     .then(() => {
        //         self.result.setSuccess(true);
        //         callback(null, self.result);
        //     })
        //     .catch((err) => {
        //         // Result success is false at invocation.
        //         self.logger.error(err.stack);
        //         callback(err, self.result);
        //     });
        //callback();
    };

    validatePetriNet.prototype.validateWithFormula = function (filePath) {
        // const streamDir = fs.mkdtempSync('stream');
        // const outFile = path.join(streamDir, 'out.log');
        // const outFd = fs.openSync(outFile, 'wx+');
        // fs.closeSync(outFd);
        // const errFile = path.join(streamDir, 'err.log');
        // const errFd = fs.openSync(errFile, 'wx+');
        // fs.closeSync(errFd);

        // const cout = fs.createWriteStream(outFile);
        // const cerr = fs.createWriteStream(errFile);

        // const console = new Console(cout, cerr);

        // //x

        // fs.unlinkSync(outFile);
        // fs.unlinkSync(errFile);
        // fs.rmdirSync(streamDir);

        const formulaPath = path.join('src', 'common', 'formula', 'publish', 'CommandLine.exe');

        //console.log(formulaPath);
        this.logger.debug(formulaPath);
        //callback(null, { ...result, path: path });
        //const formulaProcess = childProcess.spawn(formulaPath, )
    };

    validatePetriNet.prototype.buildFormulaEjsTemplate = async function () {
        const { activeNode, core } = this;

        // const htmlEntities = new Map();
        // htmlEntities.set('&lt;', '<');
        // htmlEntities.set('&gt;', '>');

        return this.getModelContentParameters().then((modelContentParams) => {
            const modelContentTemplate = core.getAttribute(activeNode, 'formulaModelContent');
            const modelContent = ejs.render(modelContentTemplate, modelContentParams);

            const domain = core.getAttribute(activeNode, 'formulaDomain');
            const name = core.getAttribute(activeNode, 'name').replace(/ /g, '');
            const modelTemplate = core.getAttribute(activeNode, 'formulaModel');
            const model = he.decode(ejs.render(modelTemplate, { domain, name, modelContent }));
            //.replace(/(&gf;)|(&lt;)/g, (match) => htmlEntities.get(match));
            return model;

            //TODO: next need to "cd formula" and run "qr <model> <domain>.conforms"
            //		and read the output, then return it (as a plugin return)
        });
    };

    validatePetriNet.prototype.getModelContentParameters = async function () {
        const { activeNode, core, META } = this;
        const trimGuid = (node) => core.getGuid(node).replace(/-/g, '');
        return await core
            .loadOwnSubTree(activeNode)
            .then(async (nodes) => {
                const modelContentParameters = { places: [], transitions: [], flows: [] };
                for (const node of nodes) {
                    const id = trimGuid(node);
                    const name = core.getAttribute(node, 'name').replace(/ /g, '');
                    if (core.isInstanceOf(node, META['Place'])) {
                        const marks = core.getAttribute(node, 'marks');
                        modelContentParameters.places.push({ id, name, marks });
                    } else if (core.isInstanceOf(node, META['Transition'])) {
                        modelContentParameters.transitions.push({ id, name });
                    } else if (core.isInstanceOf(node, META['Flow'])) {
                        const isStart = core.isInstanceOf(node, META['Input Flow']);
                        const src = await core.loadPointer(node, 'src');
                        const dst = await core.loadPointer(node, 'dst');
                        const srcId = trimGuid(core.getParent(src));
                        const dstId = trimGuid(core.getParent(dst));
                        const weight = core.getAttribute(node, 'weight');
                        modelContentParameters.flows.push({ id, srcId, dstId, weight, isStart });
                    }
                }

                return modelContentParameters;
            })
            .catch((ex) => {
                //logger.error(ex);
                throw ex;
            });
    };

    return validatePetriNet;
});
